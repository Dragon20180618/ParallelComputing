在伏特架构之前，一个线程束中的线程拥有同一个程序计数器（program counter），但
各自有不同的寄存器状态（register state），从而可以根据程序的逻辑判断选择不同的分支。
选择结构将导致逻辑分支，一个线程束的线程，在同一时刻只能执行一个共同的指令或闲置。
eg:
	if(condition)
	{
		A;
	}
	else
	{
		B;
	}
同一线程束首先运行A，暂停B；A运行完后运行B
程序分支将导致程序效率大大降低。

从伏特架构开始，引入了独立线程调度（Independent Thread Scheduling）机制。每个
线程有自己的程序计数器。

为了实现独立线程调度机制，一个代价是增加了寄存器负担：单个线程的程序计数器
一般需要使用两个寄存器。

线程束级同步函数
void __syncwarp(unsigned mask = 0xffffffff);
如果要排除一些线程，可以用一个对应的二进制位为 0 的掩码参数。
例如，掩码 0xfffffffe 代表排除第 0 号线程。

线程束表决函数
unsigned __ballot_sync(unsigned mask, int predicate);
int __all_sync(unsigned mask, int predicate);
int __any_sync(unsigned mask, int predicate);

线程束洗牌函数
T __shfl_sync(unsigned mash,T v, int srcLane, int w = warpSize)
T __shfl_up_sync(unsigned mask, T v, unsigned d, int w = warpSize)
T __shfl__down_sync(unsigned mask, T v, unsigned d, int w = warpSize)
T __shlf__xor_sync(unsigned mask,unsigned d, int w = warpSize)